"use client";

import React, { useEffect, useRef, useState } from "react";
import { suits, SuitLayer } from "../data/options";
import { SuitState } from "../hooks/useSuitConfigurator";
import { getTransparentCdnBase } from "../utils/backend";
import { getBackendBase } from "../utils/backend";

/* =====================================================================================
   CDN helpers (ostaju jer maske i strukturalni sprite-ovi su i dalje iz transparent/)
===================================================================================== */
const cdnTransparent = getTransparentCdnBase();

const fileBase = (p: string) => {
  const i = p.lastIndexOf("/");
  return i >= 0 ? p.slice(i + 1) : p;
};

const cdnPair = (src: string) => {
  const base = fileBase(src).replace(/\.(png|jpg|jpeg|webp)$/i, "");
  return { webp: `${cdnTransparent}${base}.webp`, png: `${cdnTransparent}${base}.png` } as const;
};

// Optional derived assets (generated by pipeline): shading/ and specular/
const shadingPair = (src: string) => {
  const base = fileBase(src).replace(/\.(png|jpg|jpeg|webp)$/i, "");
  return {
    webp: `${cdnTransparent}shading/${base}.webp`,
    png: `${cdnTransparent}shading/${base}.png`,
  } as const;
};
const specularPair = (src: string) => {
  const base = fileBase(src).replace(/\.(png|jpg|jpeg|webp)$/i, "");
  return {
    webp: `${cdnTransparent}specular/${base}.webp`,
    png: `${cdnTransparent}specular/${base}.png`,
  } as const;
};
const edgesPair = (src: string) => {
  const base = fileBase(src).replace(/\.(png|jpg|jpeg|webp)$/i, "");
  return {
    webp: `${cdnTransparent}edges/${base}.webp`,
    png: `${cdnTransparent}edges/${base}.png`,
  } as const;
};

// Koristimo originalni transparent sprite kao CSS masku (WebP -> PNG fallback u listi)
const toTransparentSilhouette = (src: string) => {
  const u = cdnPair(src);
  return `url(${u.webp}), url(${u.png})`;
};

/* =====================================================================================
   Vizuelni presetovi (ton, kontrast, spekular, ivice)
===================================================================================== */

// Globalni noise (1x1 tiled PNG ~ neutral gray dots). Sprecava "plastican" izgled.
// Mali je, base64 inline (nema eksternih poziva).
const NOISE_DATA =
  "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWMYefz/fwAI1QLS/7j4OQAAAABJRU5ErkJggg==";

type Tone = "light" | "medium" | "dark" | undefined;

// Ton-mapiranje (cuva dubinu crne, pojacava midtone, ali ne ?pegla? svetla)
const toneBlend = (tone?: string) => {
  switch (tone as Tone) {
    case "dark":
      return { opacity: 1, filter: "brightness(1.04) contrast(1.20) saturate(1.12)" } as const;
    case "light":
      return { opacity: 1, filter: "brightness(1.06) contrast(1.10) saturate(1.08)" } as const;
    default:
      return { opacity: 1, filter: "brightness(1.05) contrast(1.14) saturate(1.10)" } as const;
  }
};

// Parametri za ?premium? svetlo po tonu ? top/bottom soft-light, edge glow, highlight
const toneVisual = (tone?: string) => {
  if (tone === "dark")
    return {
      softLightTop: 0.08,
      softLightBottom: 0.07,
      edgeGlow: 0.055,
      specular: 0.18,
      noise: 0.16,
      vignette: 0.25,
      fineDetail: 0.06,
      fineDetailSleeve: 0.06,
      detailScale: "24%",
    };
  if (tone === "light")
    return {
      softLightTop: 0.06,
      softLightBottom: 0.05,
      edgeGlow: 0.04,
      specular: 0.13,
      noise: 0.12,
      vignette: 0.18,
      fineDetail: 0.07,
      fineDetailSleeve: 0.07,
      detailScale: "26%",
    };
  return {
    softLightTop: 0.07,
    softLightBottom: 0.06,
    edgeGlow: 0.05,
    specular: 0.16,
    noise: 0.15,
    vignette: 0.21,
    fineDetail: 0.08,
    fineDetailSleeve: 0.08,
    detailScale: "25%",
  };
};

/* =====================================================================================
   Komponenta
===================================================================================== */

type Props = { config: SuitState };

export default function SuitPreview({ config }: Props) {
  const [fabrics, setFabrics] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);

  // Pan/zoom samo na teksturu tkanine (ne menja maske)
  const [scale, setScale] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const dragRef = useRef<{ x: number; y: number; active: boolean }>({ x: 0, y: 0, active: false });

  const currentSuit = suits.find((s) => s.id === config.styleId);
  if (!currentSuit) return null;

  useEffect(() => {
    let cancelled = false;
    const url = `${getBackendBase()}fabrics.php`;
    fetch(url, { cache: "no-store" })
      .then((r) => r.json())
      .then((data) => {
        if (!cancelled && data?.success) setFabrics(data.data);
      })
      .catch((e) => console.error("Fabrics load error", e))
      .finally(() => !cancelled && setLoading(false));
    return () => {
      cancelled = true;
    };
  }, []);

  const selectedFabric = fabrics.find((f) => String(f.id) === String(config.colorId));
  const fabricTexture = selectedFabric?.texture || "";

  const tb = toneBlend(selectedFabric?.tone);
  const vis = toneVisual(selectedFabric?.tone);

  // Solid base color by tone, used under subtle fabric weave
  const toneBaseColor = (() => {
    const t = (selectedFabric?.tone || "medium") as Tone;
    if (t === "dark") return "#2b2b2b";
    if (t === "light") return "#c8c8c8";
    return "#8f8f8f";
  })();

  // Average color from fabric texture (to better match hue)
  const [fabricAvgColor, setFabricAvgColor] = useState<string | null>(null);
  const [jacketUnionMask, setJacketUnionMask] = useState<string | null>(null);
  const [compositeBase, setCompositeBase] = useState<string | null>(null);
  const [compositeShading, setCompositeShading] = useState<string | null>(null);
  const [compositeSpecular, setCompositeSpecular] = useState<string | null>(null);
  const [compositeEdges, setCompositeEdges] = useState<string | null>(null);
  const [sleevesMask, setSleevesMask] = useState<string | null>(null);
  const [torsoMask, setTorsoMask] = useState<string | null>(null);
  const compositesReady = Boolean(compositeBase && compositeShading && compositeSpecular && compositeEdges);
  useEffect(() => {
    if (!fabricTexture) {
      setFabricAvgColor(null);
      return;
    }
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      try {
        const c = document.createElement("canvas");
        const ctx = c.getContext("2d");
        if (!ctx) return;
        const w = 32,
          h = 32;
        c.width = w;
        c.height = h;
        ctx.drawImage(img, 0, 0, w, h);
        const d = ctx.getImageData(0, 0, w, h).data;
        let r = 0,
          g = 0,
          b = 0,
          n = 0;
        for (let i = 0; i < d.length; i += 4) {
          const a = d[i + 3];
          if (a < 10) continue;
          r += d[i];
          g += d[i + 1];
          b += d[i + 2];
          n++;
        }
        if (n > 0) {
          const toHex = (x: number) => Math.max(0, Math.min(255, Math.round(x))).toString(16).padStart(2, "0");
          setFabricAvgColor(`#${toHex(r / n)}${toHex(g / n)}${toHex(b / n)}`);
        } else setFabricAvgColor(null);
      } catch {}
    };
    img.onerror = () => setFabricAvgColor(null);
    img.src = fabricTexture;
  }, [fabricTexture]);

  // Build a single union mask (PNG data URL) over torso+sleeves+bottom to eliminate any anti-alias seams
  useEffect(() => {
    // Recompute adjusted layers locally so we don't depend on suitLayers declared below
    const baseLayersLocal: SuitLayer[] = currentSuit?.layers || [];
    const selectedLapelLocal =
      currentSuit?.lapels?.find((l) => l.id === config.lapelId) ?? currentSuit?.lapels?.[0];
    const selectedLapelWidthLocal =
      selectedLapelLocal?.widths.find((w) => w.id === config.lapelWidthId) ||
      selectedLapelLocal?.widths.find((w) => w.id === "medium") ||
      selectedLapelLocal?.widths?.[0];

    const swap = (src: string) =>
      src.replace(
        /lapel_(narrow|medium|wide)\+style_lapel_(notch|peak)/,
        `lapel_${selectedLapelWidthLocal?.id || "medium"}+style_lapel_${selectedLapelLocal?.id || "notch"}`
      );
    const adjusted = baseLayersLocal.map((l) => (l.id === "torso" ? { ...l, src: swap(l.src) } : l));

    const torso = adjusted.find((x) => x.id === "torso");
    const sleevesL = adjusted.find((x) => x.id === "sleeves");
    const bottomL = adjusted.find((x) => x.id === "bottom");
    const parts = [torso, sleevesL, bottomL].filter(Boolean) as SuitLayer[];
    if (!parts.length) return setJacketUnionMask(null);

    let cancelled = false;
    (async () => {
      try {
        const c = document.createElement("canvas");
        c.width = JACKET_CANVAS.w;
        c.height = JACKET_CANVAS.h;
        const ctx = c.getContext("2d");
        if (!ctx) return;
        ctx.clearRect(0, 0, c.width, c.height);
        ctx.globalCompositeOperation = "source-over";
        for (const L of parts) {
          // try webp then png
          const pair = cdnPair(L.src);
          const tryLoad = (url: string) =>
            new Promise<HTMLImageElement>((resolve, reject) => {
              const img = new Image();
              img.crossOrigin = "anonymous";
              img.onload = () => resolve(img);
              img.onerror = reject;
              img.src = url;
            });
          let img: HTMLImageElement | null = null;
          try {
            img = await tryLoad(pair.webp);
          } catch {
            try {
              img = await tryLoad(pair.png);
            } catch {}
          }
          if (!img) continue;
          const scale = Math.min(c.width / img.width, c.height / img.height);
          const w = Math.round(img.width * scale);
          const h = Math.round(img.height * scale);
          const dx = Math.round((c.width - w) / 2);
          const dy = Math.round((c.height - h) / 2);
          // draw alpha as mask (opaque where sprite has pixels)
          ctx.drawImage(img, dx, dy, w, h);
        }
        if (!cancelled) setJacketUnionMask(c.toDataURL("image/png"));
      } catch {
        if (!cancelled) setJacketUnionMask(null);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [currentSuit, config.lapelId, config.lapelWidthId, fabricTexture]);

  // Build unified sprite composites (base/shading/specular/edges) for jacket parts
  useEffect(() => {
    const baseLayersLocal: SuitLayer[] = currentSuit?.layers || [];
    const selectedLapelLocal =
      currentSuit?.lapels?.find((l) => l.id === config.lapelId) ?? currentSuit?.lapels?.[0];
    const selectedLapelWidthLocal =
      selectedLapelLocal?.widths.find((w) => w.id === config.lapelWidthId) ||
      selectedLapelLocal?.widths.find((w) => w.id === "medium") ||
      selectedLapelLocal?.widths?.[0];
    const swap = (src: string) =>
      src.replace(
        /lapel_(narrow|medium|wide)\+style_lapel_(notch|peak)/,
        `lapel_${selectedLapelWidthLocal?.id || "medium"}+style_lapel_${selectedLapelLocal?.id || "notch"}`
      );
    const adjusted = baseLayersLocal.map((l) => (l.id === "torso" ? { ...l, src: swap(l.src) } : l));
    const parts = adjusted.filter((x) => x.id === "torso" || x.id === "sleeves" || x.id === "bottom");
    if (!parts.length) return;

    let cancelled = false;
    const compose = async (
      picker: (l: SuitLayer) => { webp: string; png: string },
      w: number,
      h: number,
      customParts?: SuitLayer[]
    ) => {
      const c = document.createElement("canvas");
      c.width = w;
      c.height = h;
      const ctx = c.getContext("2d");
      if (!ctx) return null;
      ctx.clearRect(0, 0, w, h);
      const loopParts = customParts || parts;
      for (const L of loopParts) {
        const p = picker(L);
        const tryLoad = (url: string) =>
          new Promise<HTMLImageElement>((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = url;
          });
        let img: HTMLImageElement | null = null;
        try {
          img = await tryLoad(p.webp);
        } catch {
          try {
            img = await tryLoad(p.png);
          } catch {}
        }
        if (!img) continue;
        const scale = Math.min(w / img.width, h / img.height);
        const dw = Math.round(img.width * scale);
        const dh = Math.round(img.height * scale);
        const dx = Math.round((w - dw) / 2);
        const dy = Math.round((h - dh) / 2);
        ctx.drawImage(img, dx, dy, dw, dh);
      }
      return c.toDataURL("image/png");
    };

    (async () => {
      const torsoBottom = parts.filter(p => p.id === "torso" || p.id === "bottom");
      // FIX: removed sleeve edge overlap completely ï¿½ composites only for torso+bottom
      const baseUrl = await compose((l) => cdnPair(l.src), JACKET_CANVAS.w, JACKET_CANVAS.h, torsoBottom);
      const shadingUrl = await compose((l) => shadingPair(l.src), JACKET_CANVAS.w, JACKET_CANVAS.h, torsoBottom);
      const specularUrl = await compose((l) => specularPair(l.src), JACKET_CANVAS.w, JACKET_CANVAS.h, torsoBottom);
      const edgesUrl = await compose((l) => edgesPair(l.src), JACKET_CANVAS.w, JACKET_CANVAS.h, torsoBottom);
      if (!cancelled) {
        setCompositeBase(baseUrl);
        setCompositeShading(shadingUrl);
        setCompositeSpecular(specularUrl);
        setCompositeEdges(edgesUrl);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [currentSuit, config.lapelId, config.lapelWidthId]);

  // Build sleeves-only mask to equalize sleeves vs torso (lighten sleeves slightly)
  useEffect(() => {
    const baseLayersLocal: SuitLayer[] = currentSuit?.layers || [];
    const selectedLapelLocal =
      currentSuit?.lapels?.find((l) => l.id === config.lapelId) ?? currentSuit?.lapels?.[0];
    const selectedLapelWidthLocal =
      selectedLapelLocal?.widths.find((w) => w.id === config.lapelWidthId) ||
      selectedLapelLocal?.widths.find((w) => w.id === "medium") ||
      selectedLapelLocal?.widths?.[0];
    const swap = (src: string) =>
      src.replace(
        /lapel_(narrow|medium|wide)\+style_lapel_(notch|peak)/,
        `lapel_${selectedLapelWidthLocal?.id || "medium"}+style_lapel_${selectedLapelLocal?.id || "notch"}`
      );
    const adjusted = baseLayersLocal.map((l) => (l.id === "torso" ? { ...l, src: swap(l.src) } : l));
    const sleevesPart = adjusted.find((x) => x.id === "sleeves");
    if (!sleevesPart) { setSleevesMask(null); return; }

    let cancelled = false;
    (async () => {
      try {
        const c = document.createElement("canvas");
        c.width = JACKET_CANVAS.w; c.height = JACKET_CANVAS.h;
        const ctx = c.getContext("2d"); if (!ctx) return;
        const pair = cdnPair(sleevesPart.src);
        const tryLoad = (url: string) => new Promise<HTMLImageElement>((resolve, reject) => { const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>resolve(i); i.onerror=reject; i.src=url; });
        let img: HTMLImageElement | null = null;
        try { img = await tryLoad(pair.webp); } catch { try { img = await tryLoad(pair.png); } catch {} }
        if (!img) return;
        const scale = Math.min(c.width / img.width, c.height / img.height);
        const dw = Math.round(img.width * scale); const dh = Math.round(img.height * scale);
        const dx = Math.round((c.width - dw) / 2); const dy = Math.round((c.height - dh) / 2);
        ctx.drawImage(img, dx, dy, dw, dh);
        if (!cancelled) setSleevesMask(c.toDataURL("image/png"));
      } catch { if (!cancelled) setSleevesMask(null); }
    })();
    return () => { cancelled = true; };
  }, [currentSuit, config.lapelId, config.lapelWidthId]);

  // Build torso-only mask for side feathering (to hide vertical armhole seams)
  useEffect(() => {
    const baseLayersLocal: SuitLayer[] = currentSuit?.layers || [];
    const selectedLapelLocal =
      currentSuit?.lapels?.find((l) => l.id === config.lapelId) ?? currentSuit?.lapels?.[0];
    const selectedLapelWidthLocal =
      selectedLapelLocal?.widths.find((w) => w.id === config.lapelWidthId) ||
      selectedLapelLocal?.widths.find((w) => w.id === "medium") ||
      selectedLapelLocal?.widths?.[0];
    const swap = (src: string) =>
      src.replace(
        /lapel_(narrow|medium|wide)\+style_lapel_(notch|peak)/,
        `lapel_${selectedLapelWidthLocal?.id || "medium"}+style_lapel_${selectedLapelLocal?.id || "notch"}`
      );
    const adjusted = baseLayersLocal.map((l) => (l.id === "torso" ? { ...l, src: swap(l.src) } : l));
    const torsoPart = adjusted.find((x) => x.id === "torso");
    if (!torsoPart) { setTorsoMask(null); return; }

    let cancelled = false;
    (async () => {
      try {
        const c = document.createElement("canvas");
        c.width = JACKET_CANVAS.w; c.height = JACKET_CANVAS.h;
        const ctx = c.getContext("2d"); if (!ctx) return;
        const pair = cdnPair(torsoPart.src);
        const tryLoad = (url: string) => new Promise<HTMLImageElement>((resolve, reject) => { const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>resolve(i); i.onerror=reject; i.src=url; });
        let img: HTMLImageElement | null = null;
        try { img = await tryLoad(pair.webp); } catch { try { img = await tryLoad(pair.png); } catch {} }
        if (!img) return;
        const scale = Math.min(c.width / img.width, c.height / img.height);
        const dw = Math.round(img.width * scale); const dh = Math.round(img.height * scale);
        const dx = Math.round((c.width - dw) / 2); const dy = Math.round((c.height - dh) / 2);
        ctx.drawImage(img, dx, dy, dw, dh);
        if (!cancelled) setTorsoMask(c.toDataURL("image/png"));
      } catch { if (!cancelled) setTorsoMask(null); }
    })();
    return () => { cancelled = true; };
  }, [currentSuit, config.lapelId, config.lapelWidthId]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full text-gray-400 text-sm">
        Ucitavanje tkanina?
      </div>
    );
  }
  if (!selectedFabric) {
    return (
      <div className="flex items-center justify-center h-full text-gray-500 text-sm">
        Izaberi tkaninu da vidi? odelo.
      </div>
    );
  }

  /* -----------------------------------------------------------------------------
     Dinamicka zamena revera (da maska uvek prati izabrani rever)
  ----------------------------------------------------------------------------- */
  const baseLayers: SuitLayer[] = currentSuit.layers || [];
  const selectedLapel =
    currentSuit.lapels?.find((l) => l.id === config.lapelId) ?? currentSuit.lapels?.[0];
  const selectedLapelWidth =
    selectedLapel?.widths.find((w) => w.id === config.lapelWidthId) ||
    selectedLapel?.widths.find((w) => w.id === "medium") ||
    selectedLapel?.widths?.[0];

  const swapLapelInPath = (src: string, lapelType?: string, lapelWidth?: string) => {
    const type = lapelType ?? "notch";
    const width = lapelWidth ?? "medium";
    return src.replace(
      /lapel_(narrow|medium|wide)\+style_lapel_(notch|peak)/,
      `lapel_${width}+style_lapel_${type}`
    );
  };

  const suitLayers = baseLayers.map((l) =>
    l.id === "torso" ? { ...l, src: swapLapelInPath(l.src, selectedLapel?.id, selectedLapelWidth?.id) } : l
  );

  /* -----------------------------------------------------------------------------
     Opcioni slojevi (pockets/cuffs/breast pocket/interior)
  ----------------------------------------------------------------------------- */
  const pocketSrc =
    config.pocketId && currentSuit.pockets?.find((p) => p.id === config.pocketId)?.src;

  const cuffSrc =
    config.cuffId && currentSuit.cuffs?.find((c) => c.id === config.cuffId)?.src;

  const pantsPleatSrc =
    config.pantsPleatId === "double" ? "/assets/suits/blue/pleats_double.png" : undefined;

  const interiorLayers: SuitLayer[] | undefined = (() => {
    const def = currentSuit.interiors?.[0];
    const active = config.interiorId ?? def?.id;
    const found = currentSuit.interiors?.find((i) => i.id === active);
    return Array.isArray(found?.layers) ? found.layers : undefined;
  })();

  const breastPocketLayers: SuitLayer[] | undefined = (() => {
    const id = config.breastPocketId;
    const found = id ? currentSuit.breastPocket?.find((bp) => bp.id === id) : undefined;
    return Array.isArray(found?.layers) ? found.layers : undefined;
  })();

  /* -----------------------------------------------------------------------------
     Canvas konstante
  ----------------------------------------------------------------------------- */
  const JACKET_CANVAS = { w: 600, h: 733 } as const;
  const PANTS_CANVAS = { w: 600, h: 350 } as const;

  /* -----------------------------------------------------------------------------
     Helperi za tkaninu (sa pan/zoom param.)
  ----------------------------------------------------------------------------- */
  const fabricMaskStyle = (
    src: string,
    canvas: { w: number; h: number } = JACKET_CANVAS
  ): React.CSSProperties => {
    // koristimo pan/zoom nad teksturom
    const bgSize = `${Math.round(canvas.w * scale)}px ${Math.round(canvas.h * scale)}px`;
    const bgPos = `${Math.round(offset.x)}px ${Math.round(offset.y)}px`;
    return {
      backgroundImage: `url(${fabricTexture})`,
      backgroundSize: bgSize,
      backgroundPosition: bgPos,
      backgroundRepeat: "repeat", // dozvoljavamo ponavljanje zbog weave obrazaca
      opacity: tb.opacity,
      filter: tb.filter,
      WebkitMaskImage: toTransparentSilhouette(src),
      WebkitMaskRepeat: "no-repeat",
      WebkitMaskSize: "contain",
      WebkitMaskPosition: "center",
      maskImage: toTransparentSilhouette(src),
      maskRepeat: "no-repeat",
      maskSize: "contain",
      maskPosition: "center",
      pointerEvents: "none",
    } as React.CSSProperties;
  };

  // Solid color fill under the weave, same mask
  const colorBaseMaskStyle = (
    src: string
  ): React.CSSProperties => {
    return {
      backgroundColor: fabricAvgColor || toneBaseColor,
      WebkitMaskImage: toTransparentSilhouette(src),
      WebkitMaskRepeat: "no-repeat",
      WebkitMaskSize: "contain",
      WebkitMaskPosition: "center",
      maskImage: toTransparentSilhouette(src),
      maskRepeat: "no-repeat",
      maskSize: "contain",
      maskPosition: "center",
      pointerEvents: "none",
    } as React.CSSProperties;
  };

  // Subtle weave overlay on top of solid base (reduced visibility)
  const fabricWeaveOverlayStyle = (
    src: string,
    canvas: { w: number; h: number } = JACKET_CANVAS
  ): React.CSSProperties => {
    const bgSize = `${Math.round(canvas.w * scale)}px ${Math.round(canvas.h * scale)}px`;
    const bgPos = `${Math.round(offset.x)}px ${Math.round(offset.y)}px`;
    const t = (selectedFabric?.tone || "medium") as Tone;
    const op = t === "dark" ? 0.14 : t === "light" ? 0.20 : 0.17;
    return {
      backgroundImage: `url(${fabricTexture})`,
      backgroundSize: bgSize,
      backgroundPosition: bgPos,
      backgroundRepeat: "repeat",
      opacity: op,
      mixBlendMode: "normal",
      WebkitMaskImage: toTransparentSilhouette(src),
      WebkitMaskRepeat: "no-repeat",
      WebkitMaskSize: "contain",
      WebkitMaskPosition: "center",
      maskImage: toTransparentSilhouette(src),
      maskRepeat: "no-repeat",
      maskSize: "contain",
      maskPosition: "center",
      pointerEvents: "none",
    } as React.CSSProperties;
  };

  // Unified fabric base across multiple layers to avoid seams (e.g., torso + sleeves)
  const unifiedFabricBaseStyle = (layers: SuitLayer[], canvas: { w: number; h: number }) => {
    const bgSize = `${Math.round(canvas.w * scale)}px ${Math.round(canvas.h * scale)}px`;
    const bgPos = `${Math.round(offset.x)}px ${Math.round(offset.y)}px`;

    const maskImages: string[] = [];
    const maskSizes: string[] = [];
    const maskRepeats: string[] = [];
    const maskPositions: string[] = [];
    for (const L of layers) {
      const u = cdnPair(L.src);
      // WebP first, PNG fallback
      maskImages.push(`url(${u.webp})`);
      maskImages.push(`url(${u.png})`);
      maskSizes.push("contain", "contain");
      maskRepeats.push("no-repeat", "no-repeat");
      maskPositions.push("center", "center");
    }

    const style: React.CSSProperties = {
      backgroundColor: fabricAvgColor || toneBaseColor,
    };
    // FIX: sleeves transparency ? use union mask ONLY for torso/bottom, not for sleeves
    const containsSleeves = layers.some((l) => l.id === "sleeves");
    if (jacketUnionMask) {
      Object.assign(style, {
        WebkitMaskImage: `url(${jacketUnionMask})`,
        WebkitMaskRepeat: "no-repeat",
        WebkitMaskSize: "contain",
        WebkitMaskPosition: "center",
        maskImage: `url(${jacketUnionMask})`,
        maskRepeat: "no-repeat",
        maskSize: "contain",
        maskPosition: "center",
      } as React.CSSProperties);
    } else {
      Object.assign(style, {
        WebkitMaskImage: (jacketUnionMask ? `url(${jacketUnionMask})` : maskImages.join(", ")),
        WebkitMaskRepeat: (jacketUnionMask ? "no-repeat" : maskRepeats.join(", ")),
        WebkitMaskSize: (jacketUnionMask ? "contain" : maskSizes.join(", ")),
        WebkitMaskPosition: (jacketUnionMask ? "center" : maskPositions.join(", ")),
        maskImage: (jacketUnionMask ? `url(${jacketUnionMask})` : maskImages.join(", ")),
        maskRepeat: (jacketUnionMask ? "no-repeat" : maskRepeats.join(", ")),
        maskSize: (jacketUnionMask ? "contain" : maskSizes.join(", ")),
        maskPosition: (jacketUnionMask ? "center" : maskPositions.join(", ")),
      } as React.CSSProperties);
    }
    return style;
  };

  // Unified weave overlay across provided layers (prevents visible weave seams)
  const unifiedWeaveOverlayStyle = (layers: SuitLayer[], canvas: { w: number; h: number }) => {
    const bgSize = `${Math.round(canvas.w * scale)}px ${Math.round(canvas.h * scale)}px`;
    const bgPos = `${Math.round(offset.x)}px ${Math.round(offset.y)}px`;

    const maskImages: string[] = [];
    const maskSizes: string[] = [];
    const maskRepeats: string[] = [];
    const maskPositions: string[] = [];
    for (const L of layers) {
      const u = cdnPair(L.src);
      maskImages.push(`url(${u.webp})`, `url(${u.png})`);
      maskSizes.push("contain", "contain");
      maskRepeats.push("no-repeat", "no-repeat");
      maskPositions.push("center", "center");
    }

    const t = (selectedFabric?.tone || "medium") as Tone;
    // FIX: sleeves transparency ? increase fabric visibility when sleeves are in the set
    const opacity = 1;

    return {
      backgroundImage: `url(${fabricTexture})`,
      backgroundSize: bgSize,
      backgroundPosition: bgPos,
      backgroundRepeat: "repeat",
      mixBlendMode: "normal",
      opacity,
      pointerEvents: "none",
      WebkitMaskImage: (jacketUnionMask ? `url(${jacketUnionMask})` : maskImages.join(", ")),
      WebkitMaskRepeat: (jacketUnionMask ? "no-repeat" : maskRepeats.join(", ")),
      WebkitMaskSize: (jacketUnionMask ? "contain" : maskSizes.join(", ")),
      WebkitMaskPosition: (jacketUnionMask ? "center" : maskPositions.join(", ")),
      maskImage: (jacketUnionMask ? `url(${jacketUnionMask})` : maskImages.join(", ")),
      maskRepeat: (jacketUnionMask ? "no-repeat" : maskRepeats.join(", ")),
      maskSize: (jacketUnionMask ? "contain" : maskSizes.join(", ")),
      maskPosition: (jacketUnionMask ? "center" : maskPositions.join(", ")),
    } as React.CSSProperties;
  };

  // Feather the inner sleeve seam so torso/sleeve transition is invisible
  // FIX: softer sleeve transition
  const sleevesFeatherStyle: React.CSSProperties = {
    background:
      `linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0) 20%),` +
      `linear-gradient(270deg, rgba(255,255,255,0.04), rgba(255,255,255,0) 20%)`,
    mixBlendMode: "normal",
    opacity: 0.3,
    pointerEvents: "none",
  };

  // Torso side feather to hide inner sleeve vertical line (applies only to torso area)
  const torsoArmholeFeatherStyle: React.CSSProperties = {
    background:
      `linear-gradient(90deg, rgba(255,255,255,0.20), rgba(255,255,255,0) 14%),` +
      `linear-gradient(270deg, rgba(255,255,255,0.20), rgba(255,255,255,0) 14%)`,
    mixBlendMode: 'screen',
    opacity: selectedFabric?.tone === 'light' ? 0.28 : selectedFabric?.tone === 'dark' ? 0.18 : 0.22,
    WebkitMaskImage: torsoMask ? `url(${torsoMask})` : undefined,
    WebkitMaskRepeat: 'no-repeat',
    WebkitMaskSize: 'contain',
    WebkitMaskPosition: 'center',
    maskImage: torsoMask ? `url(${torsoMask})` : undefined,
    maskRepeat: 'no-repeat',
    maskSize: 'contain',
    maskPosition: 'center',
    pointerEvents: 'none',
  } as React.CSSProperties;

  // Feather the top seam of the bottom piece (waist) to eliminate horizontal line
  // FIX: waist band fully softened
  const bottomFeatherStyle = (src: string): React.CSSProperties => ({
    background:
      `linear-gradient(180deg, rgba(255,255,255,0.10) 0%, rgba(255,255,255,0.0) 60%)`,
    mixBlendMode: "normal",
    // FIX: bottom feather softened by tone
    opacity: selectedFabric?.tone === 'light' ? 0.15 : 0.25,
    WebkitMaskImage: toTransparentSilhouette(src),
    WebkitMaskRepeat: "no-repeat",
    WebkitMaskSize: "contain",
    WebkitMaskPosition: "center",
    maskImage: toTransparentSilhouette(src),
    maskRepeat: "no-repeat",
    maskSize: "contain",
    maskPosition: "center",
    pointerEvents: "none",
  });

  // Ambient occlusion for jacket (lapel and waist emphasis)
  const jacketAOStyle: React.CSSProperties = {
    background:
      // FIX: waist band removed (keep only subtle central crease)
      `linear-gradient(90deg, rgba(0,0,0,0.22) 49.5%, rgba(0,0,0,0.06) 50%, rgba(255,255,255,0) 52%)`,
    mixBlendMode: 'multiply',
    opacity: 0.18,
    WebkitMaskImage: jacketUnionMask ? `url(${jacketUnionMask})` : undefined,
    WebkitMaskRepeat: jacketUnionMask ? 'no-repeat' : undefined,
    WebkitMaskSize: jacketUnionMask ? 'contain' : undefined,
    WebkitMaskPosition: jacketUnionMask ? 'center' : undefined,
    maskImage: jacketUnionMask ? `url(${jacketUnionMask})` : undefined,
    maskRepeat: jacketUnionMask ? 'no-repeat' : undefined,
    maskSize: jacketUnionMask ? 'contain' : undefined,
    maskPosition: jacketUnionMask ? 'center' : undefined,
    pointerEvents: 'none',
  } as React.CSSProperties;

  // Unified wash overlay (soft blur) over the whole jacket via union mask
  const unifiedWashOverlayStyle = (canvas: { w: number; h: number }) => {
    const bgSize = `${Math.round(canvas.w * scale)}px ${Math.round(canvas.h * scale)}px`;
    const bgPos = `${Math.round(offset.x)}px ${Math.round(offset.y)}px`;
    return {
      backgroundImage: `url(${fabricTexture})`,
      backgroundSize: bgSize,
      backgroundPosition: bgPos,
      backgroundRepeat: "repeat",
      opacity: 0,
      filter: `${tb.filter} blur(3px) saturate(1.02)`,
      WebkitMaskImage: jacketUnionMask ? `url(${jacketUnionMask})` : undefined,
      WebkitMaskRepeat: jacketUnionMask ? "no-repeat" : undefined,
      WebkitMaskSize: jacketUnionMask ? "contain" : undefined,
      WebkitMaskPosition: jacketUnionMask ? "center" : undefined,
      maskImage: jacketUnionMask ? `url(${jacketUnionMask})` : undefined,
      maskRepeat: jacketUnionMask ? "no-repeat" : undefined,
      maskSize: jacketUnionMask ? "contain" : undefined,
      maskPosition: jacketUnionMask ? "center" : undefined,
      pointerEvents: "none",
    } as React.CSSProperties;
  };

  // Unified fine detail overlay (subtle weave highlights) over union mask
  const unifiedFineDetailOverlayStyle = (canvas: { w: number; h: number }) => {
    const bgSize = `${Math.round(canvas.w * scale)}px ${Math.round(canvas.h * scale)}px`;
    const bgPos = `${Math.round(offset.x)}px ${Math.round(offset.y)}px`;
    return {
      backgroundImage: `url(${fabricTexture})`,
      backgroundRepeat: "repeat",
      // FIX: weave scale ï¿½ consistent pixel tile size
      backgroundSize: `${Math.round(canvas.h * 0.22)}px ${Math.round(canvas.h * 0.22)}px`,
      backgroundPosition: bgPos,
      opacity: vis.fineDetail,
      mixBlendMode: "normal",
      filter: "contrast(1.04)",
      WebkitMaskImage: jacketUnionMask ? `url(${jacketUnionMask})` : undefined,
      WebkitMaskRepeat: jacketUnionMask ? "no-repeat" : undefined,
      WebkitMaskSize: jacketUnionMask ? "contain" : undefined,
      WebkitMaskPosition: jacketUnionMask ? "center" : undefined,
      maskImage: jacketUnionMask ? `url(${jacketUnionMask})` : undefined,
      maskRepeat: jacketUnionMask ? "no-repeat" : undefined,
      maskSize: jacketUnionMask ? "contain" : undefined,
      maskPosition: jacketUnionMask ? "center" : undefined,
      pointerEvents: "none",
    } as React.CSSProperties;
  };

  // Bring back baked folds/highlights from transparent base sprite (alpha PNG/WebP)
  const baseSpriteOverlayStyle = (
    src: string,
    blend: 'multiply' | 'soft-light' | 'overlay' = 'multiply',
    opacity = 0.35
  ): React.CSSProperties => {
    const u = cdnPair(src);
    return {
      backgroundImage: `url(${u.webp}), url(${u.png})`,
      backgroundRepeat: "no-repeat",
      backgroundSize: "contain",
      backgroundPosition: "center",
      mixBlendMode: blend,
      opacity,
      pointerEvents: "none",
    } as React.CSSProperties;
  };

  // Shading/specular overlays (auto-use if files exist on CDN)
  const shadingOverlayStyle = (
    src: string,
    opacity = 0.22
  ): React.CSSProperties => {
    const u = shadingPair(src);
    return {
      backgroundImage: `url(${u.webp}), url(${u.png})`,
      backgroundRepeat: "no-repeat",
      backgroundSize: "contain",
      backgroundPosition: "center",
      mixBlendMode: "multiply",
      opacity,
      WebkitMaskImage: toTransparentSilhouette(src),
      WebkitMaskRepeat: "no-repeat",
      WebkitMaskSize: "contain",
      WebkitMaskPosition: "center",
      maskImage: toTransparentSilhouette(src),
      maskRepeat: "no-repeat",
      maskSize: "contain",
      maskPosition: "center",
      pointerEvents: "none",
    } as React.CSSProperties;
  };

  const specularOverlayStyle = (
    src: string,
    opacity = 0.16
  ): React.CSSProperties => {
    const u = specularPair(src);
    return {
      backgroundImage: `url(${u.webp}), url(${u.png})`,
      backgroundRepeat: "no-repeat",
      backgroundSize: "contain",
      backgroundPosition: "center",
      mixBlendMode: "overlay",
      opacity,
      WebkitMaskImage: toTransparentSilhouette(src),
      WebkitMaskRepeat: "no-repeat",
      WebkitMaskSize: "contain",
      WebkitMaskPosition: "center",
      maskImage: toTransparentSilhouette(src),
      maskRepeat: "no-repeat",
      maskSize: "contain",
      maskPosition: "center",
      pointerEvents: "none",
      filter: "saturate(1.02)",
    } as React.CSSProperties;
  };
  const edgesOverlayStyle = (
    src: string,
    opacity = 0.38
  ): React.CSSProperties => {
    const u = edgesPair(src);
    return {
      backgroundImage: `url(${u.webp}), url(${u.png})`,
      backgroundRepeat: "no-repeat",
      backgroundSize: "contain",
      backgroundPosition: "center",
      mixBlendMode: "multiply",
      opacity,
      WebkitMaskImage: toTransparentSilhouette(src),
      WebkitMaskRepeat: "no-repeat",
      WebkitMaskSize: "contain",
      WebkitMaskPosition: "center",
      maskImage: toTransparentSilhouette(src),
      maskRepeat: "no-repeat",
      maskSize: "contain",
      maskPosition: "center",
      pointerEvents: "none",
      filter: "contrast(1.1)",
    } as React.CSSProperties;
  };

  // ?Fine detail? overlay koristi istu teksturu, ali sitniji scale i drugaciji blend
  const fineDetailStyle = (
    src: string,
    opacity: number,
    size: string,
    canvas: { w: number; h: number }
  ): React.CSSProperties => {
    // FIX: weave scale ï¿½ consistent pixel tile size
    const weavePx = Math.round(canvas.h * 0.22);
    return {
      backgroundImage: `url(${fabricTexture})`,
      backgroundRepeat: "repeat",
      backgroundSize: `${weavePx}px ${weavePx}px`,
      backgroundPosition: "center",
      opacity,
      mixBlendMode: "normal",
      filter: "contrast(1.04)",
      WebkitMaskImage: toTransparentSilhouette(src),
      WebkitMaskRepeat: "no-repeat",
      WebkitMaskSize: "contain",
      WebkitMaskPosition: "center",
      maskImage: toTransparentSilhouette(src),
      maskRepeat: "no-repeat",
      maskSize: "contain",
      maskPosition: "center",
      pointerEvents: "none",
    } as React.CSSProperties;
  };

  /* -----------------------------------------------------------------------------
     Pan/zoom handlers
  ----------------------------------------------------------------------------- */
  const onWheel: React.WheelEventHandler<HTMLDivElement> = (e) => {
    e.preventDefault();
    const delta = -e.deltaY;
    setScale((s) => Math.min(3, Math.max(1, s + delta * 0.0015)));
  };
  const onMouseDown: React.MouseEventHandler<HTMLDivElement> = (e) => {
    dragRef.current = { x: e.clientX - offset.x, y: e.clientY - offset.y, active: true };
  };
  const onMouseMove: React.MouseEventHandler<HTMLDivElement> = (e) => {
    if (!dragRef.current.active) return;
    setOffset({ x: e.clientX - dragRef.current.x, y: e.clientY - dragRef.current.y });
  };
  const onMouseUp: React.MouseEventHandler<HTMLDivElement> = () => {
    if (dragRef.current.active) dragRef.current.active = false;
  };

  /* -----------------------------------------------------------------------------
     Render redosled
  ----------------------------------------------------------------------------- */
  const pants = suitLayers.find((l) => l.id === "pants");
  const bodyLayers = suitLayers.filter((l) => l.id !== "pants");

  /* -----------------------------------------------------------------------------
     Simulirani shading/specular bez foldera:
     - global vignette (multiply)
     - top/bottom soft-light tok
     - centralni vertical specular (overlay)
     - edge glow (soft-light)
     - micro-noise (overlay)
     - per-part dodatni gradijenti (rukavi, ramena, rever)
  ----------------------------------------------------------------------------- */
  // Global overlays uklonjeni sa canvas-a da ne prave pozadinski halo izvan maske.
  // Zadr?avamo per-part naglaske i generisane mape.

  // Per-part naglasci (ramena/rukavi + rever)
  const TorsoLapelEmphasis: React.FC = () => (
    <div
      className="absolute inset-0 pointer-events-none"
      style={{
        background:
          // V senka ka dugmetu + blage dijagonalne svetle ivice revera
          `radial-gradient(80% 80% at 50% 12%, rgba(0,0,0,0.06), rgba(0,0,0,0) 45%),` +
          `linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0) 25%),` +
          `linear-gradient(225deg, rgba(255,255,255,0.05), rgba(255,255,255,0) 25%)`,
        mixBlendMode: "normal",
      }}
    />
  );

  const SleeveShoulderEmphasis: React.FC = () => (
    <div
      className="absolute inset-0 pointer-events-none"
      style={{
        background:
          // Blagi highlight po ramenima + zasencenje ka laktu
          `radial-gradient(60% 40% at 20% 5%, rgba(255,255,255,0.06), rgba(255,255,255,0) 60%),` +
          `radial-gradient(60% 40% at 80% 5%, rgba(255,255,255,0.06), rgba(255,255,255,0) 60%),` +
          `linear-gradient(180deg, rgba(0,0,0,0.05), rgba(0,0,0,0) 30%, rgba(0,0,0,0.05) 60%, rgba(0,0,0,0) 85%)`,
        mixBlendMode: "normal",
      }}
    />
  );

  /* =====================================================================================
     RENDER
  ====================================================================================== */
  const allJacketLayers = suitLayers.filter((x) => x.id === 'torso' || x.id === 'sleeves' || x.id === 'bottom');
  return (
    <div className="w-full select-none bg-white">
      <div
        className="relative mx-auto"
        style={{ width: '100%', aspectRatio: '600 / 733', maxWidth: 720 }}
        onWheel={onWheel}
        onMouseDown={onMouseDown}
        onMouseMove={onMouseMove}
        onMouseUp={onMouseUp}
        onMouseLeave={onMouseUp}
      >
        {interiorLayers?.map((l) => (
          <img key={`int-${l.id}`} src={l.src} alt={l.name} className="absolute inset-0 w-full h-full object-contain pointer-events-none" />
        ))}
        {config.showShirt && (
          <img
            src={`${cdnTransparent}shirt_to_jacket_open.png`}
            onError={(e) => {
              const local = '/assets/suits/transparent/shirt_to_jacket_open.png';
              if (e.currentTarget.src !== local) e.currentTarget.src = local;
            }}
            alt="Shirt"
            className="absolute inset-0 w-full h-full object-contain pointer-events-none"
          />
        )}
        {/* LAYER 1: Transparent base (details and shadows) */}
        {allJacketLayers.map((l) => (
          <div
            key={`base-${l.id}`}
            className="absolute inset-0"
            style={{
              backgroundImage: `url(${cdnPair(l.src).webp}), url(${cdnPair(l.src).png})`,
              backgroundRepeat: 'no-repeat',
              backgroundSize: 'contain',
              backgroundPosition: 'center',
              mixBlendMode: 'multiply',
              opacity: 0.65,
              pointerEvents: 'none',
            }}
          />
        ))}

        {/* LAYER 2: Fabric texture */}
        {allJacketLayers.map((l) => (
          <div
            key={`fabric-${l.id}`}
            className="absolute inset-0"
            style={{
              backgroundImage: `url(${fabricTexture})`,
              backgroundRepeat: 'repeat',
              backgroundSize: 'cover',
              mixBlendMode: 'soft-light',
              opacity: 0.45,
              WebkitMaskImage: toTransparentSilhouette(l.src),
              WebkitMaskRepeat: 'no-repeat',
              WebkitMaskSize: 'contain',
              WebkitMaskPosition: 'center',
              maskImage: toTransparentSilhouette(l.src),
              maskRepeat: 'no-repeat',
              maskSize: 'contain',
              maskPosition: 'center',
              pointerEvents: 'none',
            }}
          />
        ))}

        {/* LAYER 3: Fine weave overlay */}
        {allJacketLayers.map((l) => (
          <div
            key={`fine-${l.id}`}
            className="absolute inset-0"
            style={{
              backgroundImage: `url(${fabricTexture})`,
              backgroundRepeat: 'repeat',
              backgroundSize: `${Math.round(JACKET_CANVAS.h * 0.22)}px ${Math.round(JACKET_CANVAS.h * 0.22)}px`,
              opacity: 0.10,
              mixBlendMode: 'normal',
              filter: 'contrast(1.04)',
              WebkitMaskImage: toTransparentSilhouette(l.src),
              WebkitMaskRepeat: 'no-repeat',
              WebkitMaskSize: 'contain',
              WebkitMaskPosition: 'center',
              maskImage: toTransparentSilhouette(l.src),
              maskRepeat: 'no-repeat',
              maskSize: 'contain',
              maskPosition: 'center',
              pointerEvents: 'none',
            }}
          />
        ))}

        {/* LAYER 4: Specular highlights */}
        {allJacketLayers.map((l) => (
          <div
            key={`spec-${l.id}`}
            className="absolute inset-0"
            style={{
              backgroundImage: `url(${specularPair(l.src).webp}), url(${specularPair(l.src).png})`,
              backgroundRepeat: 'no-repeat',
              backgroundSize: 'contain',
              backgroundPosition: 'center',
              mixBlendMode: 'overlay',
              opacity: 0.15,
              pointerEvents: 'none',
            }}
          />
        ))}

        {/* LAYER 5: Edge shadows */}
        {allJacketLayers.map((l) => (
          <div
            key={`edge-${l.id}`}
            className="absolute inset-0"
            style={{
              backgroundImage: `url(${edgesPair(l.src).webp}), url(${edgesPair(l.src).png})`,
              backgroundRepeat: 'no-repeat',
              backgroundSize: 'contain',
              backgroundPosition: 'center',
              mixBlendMode: 'multiply',
              opacity: 0.15,
              pointerEvents: 'none',
            }}
          />
        ))}
      </div>
      {/* ======================== PANTS CANVAS ======================== */}
      {pants && (
        <div className="relative mx-auto mt-2" style={{ width: '100%', aspectRatio: '600 / 350', maxWidth: 720 }}>
          {/* CLEAN FABRIC MODE ï¿½ unified pants tone */}
          <div className="absolute inset-0" style={{ ...colorBaseMaskStyle(pants.src) }} />
          <div className="absolute inset-0" style={{ ...fabricWeaveOverlayStyle(pants.src, PANTS_CANVAS) }} />
          <div className="absolute inset-0" style={baseSpriteOverlayStyle(pants.src, 'multiply', 0.45)} />
          <div className="absolute inset-0" style={shadingOverlayStyle(pants.src, 0.20)} />
          <div className="absolute inset-0" style={specularOverlayStyle(pants.src, 0.14)} />
          <div className="absolute inset-0" style={{ ...fineDetailStyle(pants.src, 0.08, vis.detailScale, PANTS_CANVAS) }} />
        </div>
      )}
    </div>
  );
}


  // Unified sprite overlay composer (base/shading/specular/edges)
  const unifiedSpriteOverlayStyle = (
    layers: SuitLayer[],
    kind: 'base' | 'shading' | 'specular' | 'edges',
    blend: 'multiply' | 'soft-light' | 'overlay',
    opacity: number,
    unionMask?: string | null
  ): React.CSSProperties => {
    const images: string[] = [];
    const sizes: string[] = [];
    const repeats: string[] = [];
    const positions: string[] = [];
    for (const L of layers) {
      const pair = kind === 'base' ? cdnPair(L.src)
        : kind === 'shading' ? shadingPair(L.src)
        : kind === 'specular' ? specularPair(L.src)
        : edgesPair(L.src);
      images.push(`url(${pair.webp})`, `url(${pair.png})`);
      sizes.push('contain', 'contain');
      repeats.push('no-repeat', 'no-repeat');
      positions.push('center', 'center');
    }
    const style: React.CSSProperties = {
      backgroundImage: images.join(', '),
      backgroundRepeat: repeats.join(', '),
      backgroundSize: sizes.join(', '),
      backgroundPosition: positions.join(', '),
      mixBlendMode: blend,
      opacity,
      pointerEvents: 'none',
    };
    // Note: if needed we can pass a union mask in future; current callers use per-part masks
    return style;
  };









